# Wipple Datalog Engine

A simple Datalog engine in Rust, intended for an experimental new [Wipple](https://github.com/wipplelang/wipple) compiler.

## Overview

This library lets you implement a [deductive database](https://en.wikipedia.org/wiki/Deductive_database) in Rust. A deductive database is a system where _facts_ are built up over time using _rules_.

For example, if we wanted to describe the properties of the `<` (less than) and `>` (greater than) operators, we could write these rules:

```rust
struct Num;

#[derive(Fact)]
struct LessThan(Num, Num);

#[derive(Fact)]
struct GreaterThan(Num, Num);

rules! {
    let transitive =
        LessThan(a, c) if
            LessThan(a, b),
            LessThan(b, c);

    let inverse =
        GreaterThan(b, a) if
            LessThan(a, b);
}
```

The `rules!` macro defines the rules of the system...

-   `transitive`: "If `a < b` and `b < c`, then `a < c`."
-   `inverse`: "If `a < b`, then `b > a`."

...and exposes them all via a generated `rules()` function.

Importantly, this library also exposes a _trace_ of the rules used to generate each new fact. My goal is to develop a compiler that exposes these traces to the programmer so they can better understand why errors occur.

We can evaluate our rules on a few sample numbers:

```rust
let mut ctx = Context::new();

let one = Val::new("1");
let two = Val::new("2");
let three = Val::new("3");
let four = Val::new("4");

ctx.add(fact!(LessThan(one, two)));
ctx.add(fact!(LessThan(two, three)));
ctx.add(fact!(LessThan(three, four)));

ctx.run(rules()); // `rules()` is generated by the `rules!` macro

ctx.print();
```

In the output, we can see facts like `4 > 1`, along with a trace:

```
GreaterThan(4, 1) - inverse
  LessThan(1, 4) - transitive
    LessThan(1, 2)
    LessThan(2, 4) - transitive
      LessThan(2, 3)
      LessThan(3, 4)
```

## How it works

The API is implemented using procedural macros and is fully type-safe — you can't use a single variable as input to two incompatible rules. The `Num` type in the example above is never actually instantiated, it's just a marker for type inference.

Under the hood, the `rules!` macro expands to a `Plan` for each rule. Each `Step` in the plan contains an input variable and an output variable, which in practice means that each query in your rule has one known variable and one unknown variable. If you try to create a plan that doesn't follow this model, you'll get a compile-time error.

The library currently uses [naïve evaluation](https://en.wikipedia.org/wiki/Datalog#Na%C3%AFve_evaluation), which means it keeps evaluating every rule on every fact until no more facts are generated. If performance becomes a concern, I will look into better evaluation methods!

## Resources

-   [Datalog in Javascript by Stepan Parunashvili](https://www.instantdb.com/essays/datalogjs)
-   [Codebase as Database: Turning the IDE Inside Out with Datalog by Pete Vilter](https://petevilter.me/post/datalog-typechecking)
